---
title: java thread
date: 2018-01-22 00:00:00 Z
layout: post
---

## {{page.title}}
=============

<p class="meta">22 Jan 2018</p>

要汇总的几个知识点：

#### 起源：
多线程处理时缓存一致性，从高速缓存到主内存
处理器乱序执行优化

#### Java内存操作模型
JVM：定义了java虚拟机变量到主机内存的访问协议。
线程内存包含了线程所用到的所有变量的主内存copy

#### 内存操作8动作：
- lock，标识主内存变量为线程独占 
- unlock, 解锁： 释放主内存锁定变量
- read,主内存变量值传到线程工作内存
- load,工作内存变量值copy
- use，使用工作内存变量值
- assign，修改工作内存变量值
- store,线程工作内存变量值传到主内存
- write,将store的主内存变量值放入主内存变量中

**volatile**
- 1. 只要有一个线程的写操作其它所有线程立即可见
- 2. 禁止指令重排优化

Java内存模型原子性，可见性，有序性

可见性是指当一个 线程修改了共享变量的值,其他线程能够立即得知这个修改。
volatile       
synchronized       
final，初始化完成后，不会修改  

#### Java线程模型
- 线程分为:KLT,ULT,mixed
- LWP 轻量级进程和内核1:1对应
- KLT代价大，好处是系统负责线程状态管理和调度


#### Java线程调度
* 协同式，抢占式
* 协同式
线程自己控制切换,主动通知系统切换,
优点：无需考虑同步问题
缺点：线程执行时间不可控

* 抢占式(Java)
系统分配执行时间，执行线程切换
1 通过优先级来确定优先策略
2 线程自身无法

#### 线程状态

new,runnable(running, ready),waiting,blocked(线程等待获锁)，terminated

- waiting,无限等待,没有设置timeout的join，限时等待,thread, sleep   Object.wait(timeout=?)
- waiting和blocked时线程都没有cpu时间，但是waiting是等待唤醒动作或时间，blocked是解
锁


#### 线程安全
多线程访问一个对象而不需要考虑调度执行和同步操作，或者说用任何方式调用都能获得正确结果，那么这个对象就是线程安全的

不可变，绝对线程安全、 相对线程安全、 线程兼容 和 线程对立。

如何实现线程安全？

- 1 互斥同步,Synchronization，非公平抢占式
   - synchronized.
     - 1 对当前线程可重入，
     - 2 对其他阻塞
   - ReentrantLock，默认抢占可设置公平,但是可设置按照申请时间先后来的公平方式
     对当前线程可重入，等待可中断、 可实现公平锁， 以及锁可以绑 定

- 2 非阻塞同步

  - 依赖于硬件指令集上的共享内存变量冲突检测,
  - CAS指令
  - AtomicInteger

- 3 无同步

任意时候可中断的代码，只包含threadlocal变量


#### 锁优化
自适应自旋(不阻塞挂起等待解锁)，消除(堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据 对待)，粗化，轻量级锁(CAS+对象头，基于大部分锁无竞争)，偏向锁(进一步去掉CAS)
