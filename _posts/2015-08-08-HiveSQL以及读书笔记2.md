---
title: HiveSQL以及读书小结2
date: 2015-08-08 00:00:00 Z
layout: post
commentIssueId: 1
---

{{page.title}}
---
<p class='meta'>09 Aug 2015</p>

### 1.HiveSQL多表join

进行多表联合join是因为建立特征的时候各个特征来源的原始表不同，所以在处理的时候需要将不同表的特征合并
到一起。
通常使用场景是这样的sql：

```SQL
select 
  a.id, b.f1, c.f2, d.f3 
from 
(
    select id from table_1 
) a 
join 
(
  select id, f1 from table_2
) b 
on a.id = b.id
left outer join
(
  select id, f2 from table_3
) c
on a.id = c.id;
join
(
  select id, f3 from table_4
)d on a.id = d.id; 
```
那么这个SQL表达的意思就是以table_1和table_2公共的id为准，从table_2，table_3,table_4中取出对应的行，如果table_3中没有
对应行的数据，那么在最终结果中这个id对应的f2列值为null。在这个SQL处理的过程中，第一个join处理完后，第一次的结果
表中就已经没有不在table_1,table_2结果中的id了。所以如果此时再去table_4中取数据，其实就会少掉只在table_1和table_4中
的id。
此外，join操作的执行是顺序的，所以最好大表在最后。

Ref：[Hive SQL Join](https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Joins)


### 2.各种分类器特点小结

#### 2.1 基于规则的分类器

规则的来源有两种，直接从属性值来，间接从决策树神经网络等模型来。

直接抽取规则的方法是针对每个类别分别建立规则。每建立一条规则后就把该条规则覆盖的样本移除。
Learn-One-Rule函数，其目标是抽取出一个能覆盖最多正样本的分类规则。规则的生成策略有两种，特殊到一般，以及一般到
特殊。一般到特殊的方法是先从空集的规则开始，然后往里面添加属性规则来提高分类的覆盖率和准确率。而特殊到一般则是随机先
选一个目标纪录作为种子，然后呢不断依次来移除其每个属性里的�每个属性值来进行泛化。这里面其实有个问题就是，这种方法对
连续值处理起来还是蛮有难度的，可能需要先对连续值离散化下咯。

**特点**：

- 基于规则的分类表达能力跟决策树是相当的。
- 规则通常用来产生更容易解释的描述性模型，但是其表现结果却和决策树相匹配。
- 很对规则模型采用的基于类的规则排序方法能够很好的处理倾斜的数据分布情况。

#### 2.2 k-近邻分类器

其思想很简单，对于一个测试样本，计算与其相似度较高的k个样本，然后在这k个样本中，类别数最多的样本就是这个样本的
类别。这个k值呢，太小了容易因为噪声导致过拟合，太大了又可能因为把离他很远的点都包含进来。

**特点**：

- 近邻分类器呢属于实例学习算法，这类算法需要一种相似度的度量方法来计算实例之间的相似度或者说时距离。此外还需要 一个函数来计算要预测测试样例的类别
- 不需要建模，但是预测的计算代价大。
- 预测的结果是基于局部信息，而规则，决策树等是对整个输入空间建模。所以预测结果很容易受噪声点的影响。
- 数据必须要预处理好，并且选好合适的相似度度量方法，否则就会产生错误的预测结果。















